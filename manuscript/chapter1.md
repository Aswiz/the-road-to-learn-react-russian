# Введение в React

В этой главе даётся введение в React. Вы можете спросить себя: почему я должен изучить React в первую очередь? Эта глава может дать ответ на этот вопрос. После этого вы погрузитесь в экосистему, запустив (*by bootstrapping) ваше первое React-приложение с нуля с нулевой конфигурацией (*with zero-configuration). По ходу дела вы познакомитесь с JSX и ReactDOM. Поэтому будьте готовы к вашим первым компонентам React.

## Привет, меня зовут React.

**Зачем вам пытаться изучать React?** В последние годы популярные одностраничные приложения (*single page applications) ([SPA](https://en.wikipedia.org/wiki/Single-page_application)). Фреймворки, такие как Angular, Ember и Backbone, помогли разработчикам JavaScript создавать современные веб-приложения за пределами использования чистого (ванильного) JavaScript и jQuery. Список этих популярных расширений не является исчерпывающим. Существует широкий круг фреймворков для создания SPA. Если посмотреть на даты реализов, большинство из них относятся к первому поколению SPA: Angular 2010, Backbone 2010 и Ember 2011.

Facebook в 2013 году выпустил первый релиз React. React - это не SPA-фреймворк, а библиотека для разработки пользовательских интерфейсов (UI). Это только представление, буква V в аббревиатуре [MVC](https://en.wikipedia.org/wiki/Model–view–controller) (model view controller), то есть она предоставляет только уровень представления. Она позволяет вам только отображать (render) компоненты в качестве видимых элементов в браузере. Однако вся экосистемы вокруг React позволяет создавать одностраничные приложения.

Но почему вы должны рассмотреть использование React, а не первое поколения SPA-фреймворков? В то время как первое поколение фреймворков пыталось решить сразу несколько вещей, однако React только помогает вам создать слой представления. Это библиотека, а не фреймворк. За этой идеей стоит следующее: ваше представление представляет собой иерархию составных компонентов.

В React вы можете сосредоточиться на своём слое представления, перед тем как внедрять остальные концепции в приложение. Каждый другой аспект - это ещё один строительный блок вашего SPA-приложения. Эти строительные блоки необходимы для создания зрелого приложения. Они имеют два преимущества.

Во-первых, вы можете изучать строительные блоки шаг за шагом. Вам не нужно беспокоиться о том, чтобы понять их вообще. Это отличается от фреймворка, который даёт вам каждый строительный блок с самого начала. В этой книге основное внимание уделяется React как первому строительному блоку. В дальнейшем последуют всё больше строительных блоков.

Во-вторых, все строительные блоки взаимозаменяемы. Это делает экосистему вокруг React таким инновационным местом. Несколько решений конкурируют друг с другом. Вы можете выбрать наиболее привлекательное решение для вас и вашего случая.

Первое поколение SPA-фреймворков достигло уровня enterprise. Они менее гибкие. React остаётся инновационным и используется многими технологическими компаниями-лидерами, такими как [Airbnb, Netflix и, конечно же, Facebook](https://github.com/facebook/react/wiki/Sites-Using-React). Все они инвестируют в будущее React и довольны React и его экосистемой.

React, возможно, один из лучших выборов для создания современных веб-приложений в настоящее время. Он обеспечивает только уровень представления, [но экосистема React представляет собой гибкий и взаимозаменяемый фреймворк](https://www.robinwieruch.de/essential-react-libraries-framework/). React имеет небольшой API, удивительную экосистему и отличное сообщество. Вы можете прочитать о моём опыте, [почему я перешёл с Angular на React](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/). Я настоятельно рекомендую понять, почему вы выбрали React, а не другой фреймворк или библиотеку. В конце концов, каждый заинтересован узнать, куда приведёт нас React в ближайшие несколько лет.

### Упражнения

* прочитайте о том, [почему я перешёл с Angular на React](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/)
* прочитайте о [гибкой экосистеме React](https://www.robinwieruch.de/essential-react-libraries-framework/)
* прочитайте о том, [как изучать фреймвок](https://www.robinwieruch.de/how-to-learn-framework/)

## Требования

<!-- If you are coming from a different SPA framework or library, you should already be familiar with the basics of web development. If you have just started in web development, you should feel comfortable with HTML, CSS and JavaScript ES5 to learn React. The book will smoothly transition to JavaScript ES6 and beyond. I encourage you to join the official [Slack Group](https://slack-the-road-to-learn-react.wieruch.com/) for the book to get help or to help others. -->

Какие требования для чтения этой книги? Прежде всего, вы должны быть знакомы с основами веб-разработки. Вы должны знать, как использовать HTML, CSS и JavaScript. Возможно, имеет смысл также знать, что такое означает термин [API](https://www.robinwieruch.de/what-is-an-api-javascript/), потому что вы будете использовать API в книге. Кроме того, я призываю вас вступить в официальную [группу в Slack](https://slack-the-road-to-learn-react.wieruch.com/) этой книги для получения помощи или помочь другим.


### Редактор и терминал

Как насчёт среды разработки? Вам понадобится работающий редактор или IDE, а также терминал (инструмент командной строки). Вы можете [последовать моему руководству по настройке](https://www.robinwieruch.de/developer-setup/). Он предназначен для пользователей MacOS, но вы также можете найти руководство по настройке для Windows. В общем, есть масса статей, которые покажут вам, как наилучшим образом настроить окружение для веб-разработки для используемой вами ОС.

При желании вы можете использовать git и GitHub при выполнении упражнений в книге для отслеживания прогресса изучения в репозиториях на GitHub. Существует [небольшое руководство](https://www.robinwieruch.de/git-essential-commands/) по использованию этих инструментов. Но опять же, это не необязательно для книги и может стать сдерживающим фактором при изучении всего этого с нуля. Таким образом, вы можете пропустить это, если вы новичок в веб-разработке, чтобы сосредоточиться на основных частях, проиллюстрированных в книге.

### Node and NPM

И последнее, но не менее важное: вам потребуется установка [node и npm](https://nodejs.org/en/). Оба они используются для управления библиотеками, которые нам понадобятся по ходу дела. В этой книге вы будете устанавливать внешние пакеты node через npm (node package manager). Эти node-пакеты могут быть библиотеками или целыми фреймворками.

Проверить версии node и npm можно в командной строке. Если вы не видите какой-либо вывод в терминале, вам сначала нужно установить node и npm. Ниже показаны только мои версии, которые я использовал во время написания книги:

{title="Command Line",lang="text"}
~~~~~~~~
node --version
*v8.9.4
npm --version
*v5.6.0
~~~~~~~~

## node and npm

В этой главе приведён небольшой обзор node и npm. Он не исчерпывающий, но даст вам необходимые инструменты. Если вы знакомы с обоими их них, то вы можете пропустить эту главу.

**Менеджер пакетов node** - npm (node package manager) позволяет устанавливать **пакеты node (node packages)** из командной строки. Эти пакеты могут быть набором утилитарных функций, библиотеками или целыми фреймворками. Все они являются зависимостями вашего приложения. Вы можете установить все эти зависимости в папку с глобальными или локальными node-пакетами.

Глобальные node-пакеты доступны из любого места в терминале, и их необходимо установить только один раз в глобальный каталог. Вы можете установить глобальный пакет, введя в терминал:

{title="Command Line",lang="text"}
~~~~~~~~
npm install -g <package>
~~~~~~~~

Флаг `-g` сообщает npm установить пакет глобально. Локальные пакеты используются в вашем приложении. Например, React как библиотека будет локальным пакетом, которая требуется для работы вашего приложения. Вы можете установить его через терминал, набрав:

{title="Command Line",lang="text"}
~~~~~~~~
npm install <package>
~~~~~~~~

Команда установки React будет выглядит следующим образом:

{title="Command Line",lang="text"}
~~~~~~~~
npm install react
~~~~~~~~

Установленный пакет автоматически появится в папке *node_modules/* и будет перечислен в файле *package.json* вместе с другими зависимостями.

Но как инициализировать папку *node_modules/* и файла *package.json* для проекта в первую очередь? Для этого у нас есть команда npm, инициализирующая проект npm и, следовательно, файл *package.json*. Только тогда, когда у вас есть этот файл, вы можете установить новые пакеты, используя npm.

{title="Command Line",lang="text"}
~~~~~~~~
npm init -y
~~~~~~~~

Флаг `-y` - ярлык для инициализации всех значений по умолчанию в *package.json*. Без использования этого флага, вам нужно самому решить, как сконфигурировать этот файл. После инициализации вашего npm-проекта вы готовы к установке новых пакетов через команду `npm install <package>`.

Ещё пару слов об *package.json*. Данный файл позволяет вам поделиться вашим проектом с другими разработчиками без передачи всех node-пакетов. Этот файл содержит все ссылки на пакеты node, используемые в вашем проекте. Эти пакеты называются зависимостями. Каждый может скопировать ваш проект без этих зависимостей. Зависимости - это ссылки в *package.json*. Кто-то, кто копирует ваш проект, может просто установит все пакеты, используя `npm install` в командной строке. Команда `npm install` возьмёт все зависимости, перечисленные в файле *package.json* и установит их в папку *node_modules/*.

Я хочу рассмотреть ещё одну npm-команду:

{title="Command Line",lang="text"}
~~~~~~~~
npm install --save-dev <package>
~~~~~~~~

Флаг `--save-dev` указывает, что пакет node используется только в окружении разработки. Он не будет использоваться в рабочем окружении (production) при развёртывании вашего приложения на сервер. Что такой пакет node делает? Представьте, что вы хотите протестировать приложение с помощью node-пакета. Вам нужно установить этот пакет через npm, но вы хотите исключить его из рабочего окружения. Тестирование должно происходить только в процессе разработки, а не тогда, когда приложение уже работает в эксплуатационном режиме. Там вам больше не нужно тестировать приложение. Он должен быть уже протестирован и работать из коробки out of the box для ваших пользователей. Это как раз тот случай, когда вы захотите использовать флаг `--save-dev`.

Вы встретите больше команд npm по ходу чтения. Но пока этого будет достаточно.

### Упражнения:

* установка npm-проекта
  * создать каталог с помощью `mkdir <folder_name>`
  * перейти в каталог с помощью `cd <folder_name>`
  * выполнить `npm init -y` или `npm init`
  * установить локальный пакет React с помощью `npm install react`
  * посмотрите файл *package.json* и каталог *node_modules/*
  * выяснить самостоятельно, как удалить node-пакет *react* 
* узнать больше о [npm](https://docs.npmjs.com/)

## Установка

Существует несколько подходов начать работу с приложением React.

Первый из них - использовать CDN. Это может звучать сложно, чем есть на самом деле. A CDN - [сеть доставки содержимого](https://ru.wikipedia.org/wiki/Content_Delivery_Network). У нескольких компаний есть CDN, которые публично размещают файлы, чтобы люди могли их. Этими файлами могут быть библиотеки, такие как React, потому что в конце концов собранная (bundled) библиотека React - это обычный JavaScript-файл *react.js*. Он может быть размещен где-то, и вы можете использовать его в своём приложении.

Как использовать CDN для начала работы с React? Вы можете встроить его в HTML-разметку с помощью тега `<script>`, со ссылкой, которая будет указывать на URL-адрес CDN. Для начала работы с React вам нужны файла (библиотеки): *react* и *react-dom*.

{title="Code Playground",lang="javascript"}
~~~~~~~~
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
~~~~~~~~

Но почему мы должны использовать CDN, когда есть npm для установки node-пакетов, таких как React?

Когда в приложении есть файл *package.json*, вы можете установить *react* и *react-dom* из командной строки. Требуется, чтобы папка была инициализирована как npm-проект, используя `npm init -y` с файлом *package.json*. Вы можете установить несколько node-пакетов в одну строку через npm.

{title="Command Line",lang="text"}
~~~~~~~~
npm install react react-dom
~~~~~~~~

Данный подход часто используется для добавления React в существующее приложение, управляемое с использованием npm.

К сожалению, это ещё не всё. Вам придётся столкнуться с [Babel](http://babeljs.io/) для того, чтобы приложение могло использовать JSX (синтаксис React) и JavaScript ES6. Babel преобразует (transpiles) ваш код так, чтобы браузере могли интерпретировать код JavaScript ES6 и JSX. Не все браузеры способны интерпретировать этот синтаксис. Эта установка включает в себя много настроек и инструментов. Это может быть слишком трудным для новичков в React, чтобы возиться со всей этой конфигурацией самостоятельно.

По этой причине Facebook представил *create-react-app* в качестве решение для быстрого старта создания React-приложений с нулевой конфигурацией (zero-configuration). В следующей главе будет показано, как настроить приложение, используя этот инструмент начальной загрузки (bootstrapping tool) .

### Упражнения:

* узнать больше про [установку React](https://reactjs.org/docs/try-react.html)

## Установка без конфигурации

В нашей книге вы будете использовать [create-react-app](https://github.com/facebookincubator/create-react-app) для начальной инициализации (bootstrap) вашего приложения. Это самоуверенный, но с нулевой конфигурацией  стартовый набор для React, представленный Facebook в 2016. [96% людей  порекомендуют его начинающим](https://twitter.com/dan_abramov/status/806985854099062785). В *create-react-app* инструменты и конфигурация отходит на задний план, когда как  основное внимание уделяется реализации приложения.

Чтобы начать работу, вам нужно установить пакет в каталог глобальных node-пакетов. После этого у вас всегда есть возможность из командной строки для первоначальной настройки новых React-приложений.

{title="Command Line",lang="text"}
~~~~~~~~
npm install -g create-react-app
~~~~~~~~

Вы можете проверить версию *create-react-app*, чтобы убедиться в успешной установки из командной строки:

{title="Command Line",lang="text"}
~~~~~~~~
create-react-app --version
*v1.5.1
~~~~~~~~

Теперь вы можете инициализировать своё первое React-приложение. Мы назовём его *hackernews*, но вы можете выбрать другое имя. Весь процесс настройки займет пару секунд. После этого перейдите в папку:

{title="Command Line",lang="text"}
~~~~~~~~
create-react-app hackernews
cd hackernews
~~~~~~~~

Теперь вы можете открыть приложение в своём редакторе. Будет представлена следующая структура папок или её вариация, в зависимости от версии *create-react-app*:

{title="Folder Structure",lang="text"}
~~~~~~~~
hackernews/
  README.md
  node_modules/
  package.json
  .gitignore
  public/
    favicon.ico
    index.html
    manifest.json
  src/
    App.css
    App.js
    App.test.js
    index.css
    index.js
    logo.svg
    registerServiceWorker.js
~~~~~~~~

Давайте сделаем небольшую паузу и посмотрим на папки и файлы. Это нормально, если вы не понимаете их все в начале.

* **README.md:** Расширение .md указывает, что текстовый файл в формате markdown. Markdown используется как легкий язык разметки с синтаксисом для форматирования текста. Во многих проектах с открытым исходным кодом есть файл *README.md*, чтобы дать вам первоначальные инструкции по проекту. Когда вы размещаете свой проект на такой платформе, как GitHub, при открытии репозитория вы увидите визуальное содержимое этого файла *README.md*. Поскольку вы использовали  *create-react-app*, ваш *README.md* будет таким же, как в [GitHub-репозитории create-react-app](https://github.com/facebookincubator/create-react-app).

* **node_modules/:** В этой папке находятся все node-пакеты, которые были и будет установлены через npm. Так как вы использовали *create-react-app*, здесь должно уже быть пару установленных node-модулей. Обычно вы никогда не будете иметь дело с этим каталогом, а только лишь при установке или удалении node-пакетов с помощью npm из командной строки.

* **package.json:** Данный файл показывает список зависимостей node-пакетов и прочую конфигурационную информацию проекта.

* **.gitignore:** В этом файле указываются все файлы и каталоги, которые не должны быть добавлены в ваш git-репозиторий при использовании git. Этот файл должен быть находится в корне проекта, как и сейчас есть. Каталог _node_modules/_ как раз является таким случаем. Достаточно поделиться файлом _package.json_ с вашими коллегами, чтобы они смогли самостоятельно установить все зависимости без предоставления всей папки с зависимостями.

* **public/:** Этот каталог содержит корневые файлы разработки, такие как _public/index.html_. Это индексный файл, который отображается при переходе на localhost:3000 во время разработки приложения. Стандартная загоовка (boilerplate) заботиться о том, чтобы связать этот индексный файл with со всеми скриптами в _src/_.

* **build/** Этот каталог будет создан при сборки проекта для продакшена. Он содержит все готовые файлы при сборке приложения для продакшен-окружения. Весь ваш написанный код в каталогах _src/_ и _public/_ объединиться (bundled) в пару файлов при запуске сборки проекта и будут доступны в каталоге build.

* **manifest.json** and **registerServiceWorker.js:** не обращайте внимания на эти файлы на данном этапе, нам они не понадобятся в этом проекте.

В конце концов, вам не нужно трогать указанные файлы и каталоги. В самом начале всё, что вам нужно, находится в каталоге *src/*. Основное внимание уделяется файлу *src/App.js* для реализации React-компонентов. Он будет использоваться для реализации приложения, но позже вы можете разделить свои компоненты на несколько файлов, тогда как каждый файл представляет собой один или несколько компонентов.

Кроме того, вы найдёте файл *src/App.test.js* для своих тестов и *src/index.js* как точку входа (entry point) в мир React. Об этих двух файлов вы узнаете в следующей главе. Вдобавок есть файл *src/index.css* и *src/App.css* для стилизации общего приложения и ваших компонентов. Все они имеют стили по умолчанию, если вы их откроете.

Приложение *create-react-app* - проект npm. Вы использовать npm для установки и удаления node-пакетов. Кроме того, вместе с ним идут npm-скриптов для выполения в командной строке:

{title="Command Line",lang="text"}
~~~~~~~~
// Запускает приложение по адресу http://localhost:3000
npm start

// Запускает выполнение тестов
npm test

// Запускает сборку приложения для продакшена
npm run build
~~~~~~~~

Эти скрипты определены в вашем *package.json*. Теперь заготовка для React-приложения готова к работе. Увлекательная часть ждёт вас в упражнениях, где вы запустите, наконец, созданное приложение в браузере.

### Упражнения:

* выполнить команду `npm start` и перейти к просмотру приложения в вашем браузере (вы можете выйти из команды, завершить её, нажав на Control + C )
* запустить интерактивный скрипт `npm test`
* запустить скрипт `npm run build` и убедиться, что в проекте создался каталог *build/* (вы можете удалить его потом; обратите внимание, что каталог сборки может использоваться позже для [деплоя приложения](https://www.robinwieruch.de/deploy-applications-digital-ocean/))
* ознакомьтесь со структурой каталогов
* ознакомьтесь с содержимым файлов
* узнать больше про [npm-скрипты и create-react-app](https://github.com/facebookincubator/create-react-app)

## Введение в JSX

Теперь вы узнаете о JSX. Это синтаксис React. Как уже упоминалось ранее, *create-react-app* уже подготовил заготовку для приложения для вас. Каждый файл имеет реализацию по умолчанию. Давайте погрузимся в исходный код. Единственным файлом, с которым вы в первую очередь будете работать - *src/App.js*.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h1 className="App-title">Добро пожаловать в React</h1>
        </header>
        <p className="App-intro">
          Для начала отредактируйте <code>src/App.js</code> и сохраните для перезагрузки.
        </p>
      </div>
    );
  }
}

export default App;
~~~~~~~~

Не позволяйте себе путаться в выражениях import/export и объявлении класса. Эти возможности уже JavaScript ES6. Мы рассмотрим их в следующей главе.

В файле есть **React-компонент, определенный через класс ES6** с именем App. Это объявление компонента. В основном после того, как вы объявили компонент, вы можете использовать его в качестве элемента повсюду в своём приложении. Он будет создавать **экземпляр** вашего **компонента** или другими словами: компонент получает экземпляр.

Возвращаемый **элемент** указывается в методе `render()`. Элементы - это то, из чего сделаны компоненты. Важно понимать различия между компонентом, экземпляром и элементом.

Довольно скоро вы увидите, где создаётся экземпляр компонента App. В противном случае вы не увидите отрисованный вывод, не так ли? Компонент App - это только объявление, но не его использование. Вы должны инстанцировать компонент где-то в своём JSX с помощью `<App />`.

Содержимое в блоке render выглядит довольно похожим на HTML, но это JSX. JSX позволяет смешивать HTML и JavaScript. Он мощный, но сбивающий с толку, когда вы используете его для разделения HTML и JavaScript. Вот почему хорошей отправной точкой считается использовать обычный HTML в JSX. Для начала откройте файл `App.js` и удалите весь ненужный HTML-код, как показано ниже.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

class App extends Component {
  render() {
    return (
      <div className="App">
        <h2>Welcome to the Road to learn React</h2>
      </div>
    );
  }
}

export default App;
~~~~~~~~

Теперь вы возвращаете только HTML из метода `render()` без всякого JavaScript. Давайте определим "Добро пожаловать в Путь к изучению React" в качестве переменной. Переменная может использоваться в JSX с использованием фигурных скобок.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

class App extends Component {
  render() {
# leanpub-start-insert
    var helloWorld = 'Welcome to the Road to learn React';
# leanpub-end-insert
    return (
      <div className="App">
# leanpub-start-insert
        <h2>{helloWorld}</h2>
# leanpub-end-insert
      </div>
    );
  }
}

export default App;
~~~~~~~~

Он должен заработать, когда вы запустите своё приложение в командной строке с помощью команды `npm start` снова.

Кроме того, вы могли заметить атрибут `className`. Он представляет стандартный атрибут `class` в HTML. По техническим причинам JSX пришлось заменить несколько встроенных HTML-атрибутов. Вы можете найти все [поддерживаемые HTML-атрибуты в документации к React](https://reactjs.org/docs/dom-elements.html#all-supported-html-attributes). Они все они следует соглашению написания в camelCase. На вашем пути к изучению React, вы столкнётесь с некоторыми специфическими атрибутами JSX.

### Упражнения:

* определить больше переменные и отрисовать их в вашем JSX
  * использовать сложный объект для представления пользователя с именем и фамилией
  * отрисовать свойства пользователя в своём JSX
* более подробно ознакомиться с [JSX](https://reactjs.org/docs/introducing-jsx.html)
* узнать подробнее о [React-компонентах, элементах и экземпляров](https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html)

## const и let в ES6

Я думаю, вы заметили, что мы объявили переменную `helloWorld`, используя выражение `var`. В JavaScript ES6 появились два варианта для определения переменных: `const` и `let`. В JavaScript ES6 вы редко найдёте больше  использование `var`.

Переменная, объявленная с помощью `const`, не может быть повторно объявлена или изменена (они неизменяемая). Как только структура данных определена, вы не сможете её изменить.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// изменение не разрешено
const helloWorld = 'Добро пожаловать в Путь к изучению React';
helloWorld = 'Пока-пока, React';
~~~~~~~~

Переменная, объявленная с помощью `let` может быть изменена.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// изменение разрешено
let helloWorld = 'Добро пожаловать в Путь к изучению React';
helloWorld = 'Пока-пока, React';
~~~~~~~~

Вы будете использовать это, когда вам требуется повторно переназначить переменную.

Однако нужно быть аккуратнее с `const`. Переменная, объявленная с `const` не может быть изменена. Но в случае если эта переменная - массив или объект, значение измениться, как обычно. Подобное значение не является неизменяемым.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// изменение разрешено
const helloWorld = {
  text: 'Добро пожаловать в Путь к изучению React'
};
helloWorld.text = 'Пока-пока, React';
~~~~~~~~

Но в каких случаях использовать тот или иной способ определения переменной? Существуют разные мнения на этот счёт. Я предлагаю использовать `const` каждый раз при определении переменной. Это будет означать, что вы хотите иметь неизменяемую структуру данных, даже несмотря на то, что значения в объектах и массивах могут изменяться. Если переменная будет изменяемой, то вы можете использовать `let`. 

Неизменяемость охватывает React и его экосистему. Вот почему `const` должен быть вашим выбором по умолчанию при определении переменной. Тем не менее, в сложных объектах значения внутри могут быть изменены. Будьте осторожны с этим поведением.

В вашем приложении используйте `const` вместо `var`.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

class App extends Component {
  render() {
# leanpub-start-insert
    const helloWorld = 'Welcome to the Road to learn React';
# leanpub-end-insert
    return (
      <div className="App">
        <h2>{helloWorld}</h2>
      </div>
    );
  }
}

export default App;
~~~~~~~~

### Упражнения:

* узнать больше о [выражении ES6 const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)
* узнать больше о [выражении ES6 let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)
* исследуйте подробнее о неизменяемых структур данных
  * почему они вообще имеют смысл в программировании 
  * почему они используются в React и его экосистеме

## ReactDOM

Прежде чем продолжить с компонентом App, возможно, вы захотите посмотреть, где он используется. Он используется в вашей точке входа в мир React: файл *src/index.js* file.

{title="src/index.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

ReactDOM.render(
  <App />,
  document.getElementById('root')
);
~~~~~~~~

В основном `ReactDOM.render()` использует DOM-узел в вашей HTML-разметке для замены его вашим JSX. Вот так легко вы можете интегрировать React в любом стороннем приложении. Запрещается использовать `ReactDOM.render()` несколько раз в приложении. Вы можете использовать его в нескольких местах для начальной загрузки простого JSX-синтаксиса, React-компонента, несколько React-компонентов или всего приложения. Но в простом React-приложении вы будете использовать его только один раз для инициализации всего дерева компонентов.

`ReactDOM.render()` ожидает два аргумента. Первый аргумент - JSX, который будет отрисовываться. Второй аргумент указывает место, куда React-приложение привяжется к вашему HTML. Он ожидает элемент с `id='root'`. Вы можете открыть файл *public/index.html* чтобы найти этот атрибут.

В текущей реализации `ReactDOM.render()` уже принимает компонент App. Тем не менее, было бы неплохо передать более простой JSX. Это необязательно должно быть инстанцирование компонента.

{title="Code Playground",lang=javascript}
~~~~~~~~
ReactDOM.render(
  <h1>Привет, мир React</h1>,
  document.getElementById('root')
);
~~~~~~~~

### Упражнения:

* открыть *public/index.html*, чтобы посмотреть где React-приложения монтируется в ваш HTML
* узнать больше об [отрисовке элементов в React](https://reactjs.org/docs/rendering-elements.html)

## Горячая перезагрузка

Есть одна вещь, которую вы можете сделать в файле *src/index.js* для улучшения опыта разработки в качестве разработчика. Но это не обязательно и не должно перегружать вас в начале изучения React.

В *create-react-app* уже есть возможность, которая автоматически обновляет страницу в браузере при изменении исходного кода. Попробуйте сами, изменив переменную `helloWorld` в файле *src/App.js*. Браузер должен обновить содержимое страницы. Но есть лучший способ сделать это.

Горячая перезагрузка модулей или замена модулей без полной перезагрузки страницы (Hot Module Replacement, HMR) - это инструмент для перезагрузки приложения в браузере. Браузер не выполняет обновление страницы. Вы можете легко активировать его в *create-react-app*. В вашем *src/index.js*, точке входа React, вы можете добавить одну небольшую настройку.

{title="src/index.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

ReactDOM.render(
  <App />,
  document.getElementById('root')
);

# leanpub-start-insert
if (module.hot) {
  module.hot.accept();
}
# leanpub-end-insert
~~~~~~~~

Вот и всё. Повторите попытку изменить переменную `helloWorld` в файле *src/App.js*. Браузер не должен обновить страницу, но приложение перезагрузится и покажет корректный (актуальный) вывод. У HMR есть несколько преимуществ:

Представьте, что делаете отладку кода с использованием выражениий  `console.log()`. Эти выражения останутся в консоли разработчика, даже если вы изменили код, потому что браузер больше не обновляет странцу. Это может быть удобно для целей отладки.

В развивающемся приложении обновление страницы задерживает вашу продуктивность. Вы должны подождать, пока страница загрузится. Перезагрузка страницы может занять несколько секунд в большом приложении. HMR устраняет этот недостаток.

Самое большое преимущество в том, что вы можете сохранить состояние с помощью HMR. Представьте, что у вас есть диалоговое окно в вашем приложении с несколькими шагами, и вы находитесь на шаге 3.

The biggest benefit is that you can keep the application state with HMR. Imagine you have a dialog in your application with multiple steps and you are at step 3. В целом, это напоминает мастер настройки. Без HMR вы измените исходный код, и браузер обновит страницу. Вам нужно снова открыть диалоговое окно и перейти с шана 1 на шаг 3. С использованием HMR диалоговое окно остаётся открытым на шаге 3. Он сохраняет состояние приложения, даже если исходный код изменяется. Перезагружается только само приложение, а не страница.

### Упражнения:

* измените исходный код *src/App.js* несколько раз, чтобы увидеть работу HMR в действии
* посмотреть первые 10 минут видео Дэна Абрамова (Dan Abramov) [Live React: Hot Reloading with Time Travel](https://www.youtube.com/watch?v=xsSnOQynTHs)

## Комплексный JavaScript в JSX

Вернёмся в нашему компоненту App. До сих пор вы отрисовывали некоторые примитивные переменные в вашем JSX. Теперь вы начнёте отрисовывать список элементов. Список будет состоят из демонстрационных данных в начале, но позже данные вы будете получать из внешнего [API](https://www.robinwieruch.de/what-is-an-api-javascript/). Это будет намного интереснее.

Сначала определим список элементов.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

# leanpub-start-insert
const list = [
  {
    title: 'React',
    url: 'https://facebook.github.io/react/',
    author: 'Jordan Walke',
    num_comments: 3,
    points: 4,
    objectID: 0,
  },
  {
    title: 'Redux',
    url: 'https://github.com/reactjs/redux',
    author: 'Dan Abramov, Andrew Clark',
    num_comments: 2,
    points: 5,
    objectID: 1,
  },
];
# leanpub-end-insert

class App extends Component {
  ...
}
~~~~~~~~

Демоданные представляют данные, которые будут получены позже из API. Элемент в списке имеет заголовок, ссылку и автора. Кроме того, он содержит идентификатор, баллы (которые указывают, насколько популярна статья) и количество комментариев.

Теперь вы можете использовать встроенную функцию JavaScript `map` в JSX. Она позволяет вам перебирать список элементов для их отображения. Снова вы будете использовать фигурные скобки для вставки (инкапсуляции) JavaScript-выражений в вашем JSX.

{title="src/App.js",lang=javascript}
~~~~~~~~
class App extends Component {
  render() {
    return (
      <div className="App">
# leanpub-start-insert
        {list.map(function(item) {
          return <div>{item.title}</div>;
        })}
# leanpub-end-insert
      </div>
    );
  }
}

export default App;
~~~~~~~~

Использование JavaScript в HTML довольно эффективно в JSX. Обычно вы могли использовать `map` для преобразования одного списка элементов список элементов. Но на этот раз вы используете `map` для преобразования списка элементов в HTML-элементы.

Пока что для каждого элемента отображается `title`. Давайте отобразим ещё больше свойств элементов.

{title="src/App.js",lang=javascript}
~~~~~~~~
class App extends Component {
  render() {
    return (
      <div className="App">
# leanpub-start-insert
        {list.map(function(item) {
          return (
            <div>
              <span>
                <a href={item.url}>{item.title}</a>
              </span>
              <span>{item.author}</span>
              <span>{item.num_comments}</span>
              <span>{item.points}</span>
            </div>
          );
        })}
# leanpub-end-insert
      </div>
    );
  }
}

export default App;
~~~~~~~~

Вы можете увидеть, что функция map просто встроена в ваш JSX. Каждое свойство элемента отображается в теге `<span>`. Кроме того, свойство url элемента используется в атрибуте `href` тега якоря.

React выполнит всю работу за вас и отобразит каждый элемент. Но вы должны добавить одного помощника для React, чтобы полностью использовать его потенциал и улучшить его производительность. Вы должны назначить атрибут ключа каждому элементу списка. Таким образом, React может идентифицировать добавленные, изменённые и удалённые элементы при изменении списка. У элементов списка демоданных уже есть идентификатор.

{title="src/App.js",lang=javascript}
~~~~~~~~
{list.map(function(item) {
  return (
# leanpub-start-insert
    <div key={item.objectID}>
# leanpub-end-insert
      <span>
        <a href={item.url}>{item.title}</a>
      </span>
      <span>{item.author}</span>
      <span>{item.num_comments}</span>
      <span>{item.points}</span>
    </div>
  );
})}
~~~~~~~~

Вы должны убедиться, что атрибут key - уникальный идентификатор. Не допускайте ошибку, использовав индекс элемента в массиве. Индекс массива непостоянный вовсе. Например, когда список изменяет свой порядок, React будет трудно идентифицировать элементы правильно.

You should make sure that the key attribute is a stable identifier. Don't make the mistake of using index of the item in the array. The array index isn't stable at all. For instance, when the list changes its order, React will have a hard time identifying the items properly.

{title="src/App.js",lang=javascript}
~~~~~~~~
// не делайте так
{list.map(function(item, key) {
  return (
    <div key={key}>
      ...
    </div>
  );
})}
~~~~~~~~

Теперь вы отображаете оба списка. Вы можете запустить приложение, открыть браузер и увидеть оба элемента списка.

### Exercises:

* узнать подробнее о [списках и ключах React](https://reactjs.org/docs/lists-and-keys.html)
* повторить [стандартные встроенные функции массива в JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
* использовать больше JavaScript-выражений в JSX

## Стрелочные функции ES6

JavaScript ES6 представил стрелочные функции (arrow functions). Выражение стрелочной функции короче функциональных выражений.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// функция
function () { ... }

// стрелочная функция
() => { ... }
~~~~~~~~

Но вы должны знать о её функциональности. Одно из них - это другое поведение с объектом `this`. Функция всегда определяет свой собственный объект `this`. Стрелочная функция по-прежнему имеет объект `this` окружающего контекста.

But you have to be aware of its functionalities. One of them is a different behavior with the `this` object. A function expression always defines its own `this` object. Arrow function expressions still have the `this` object of the enclosing context. Пусть вас не сбивает с толку использование `this` в стрелочной функции.

Существует ещё один ценный факт о стрелочных функций относительно круглых скобок. Вы можете удалить круглые скобки, когда функция принимает только один аргумент, но они требуется в случае нескольких аргументов.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// разрешено
item => { ... }

// разрешено
(item) => { ... }

// не разрешено
item, key => { ... }

// разрешено
(item, key) => { ... }
~~~~~~~~

Однако, давайте посмотрим на функцию `map`. Вы можете написать это более кратко с помощью стрелочных функций из ES6.

{title="src/App.js",lang=javascript}
~~~~~~~~
# leanpub-start-insert
{list.map(item => {
# leanpub-end-insert
  return (
    <div key={item.objectID}>
      <span>
        <a href={item.url}>{item.title}</a>
      </span>
      <span>{item.author}</span>
      <span>{item.num_comments}</span>
      <span>{item.points}</span>
    </div>
  );
})}
~~~~~~~~

Кроме того, вы можете удалить *тело блока*, то есть фигурные скобки стрелочной функции ES6. В *сокращённом теле* подразумевается неявный возврат. Таким образом, вы можете удалить выражение return. Такая форма стрелочной функции в книге будет использоваться чаще, поэтому убедитесь, что понимаете между тело блока и a сокращённым телом при использовании стрелочных функций.

{title="src/App.js",lang=javascript}
~~~~~~~~
# leanpub-start-insert
{list.map(item =>
# leanpub-end-insert
  <div key={item.objectID}>
    <span>
      <a href={item.url}>{item.title}</a>
    </span>
    <span>{item.author}</span>
    <span>{item.num_comments}</span>
    <span>{item.points}</span>
  </div>
# leanpub-start-insert
)}
# leanpub-end-insert
~~~~~~~~

Теперь ваш JSX выглядит более кратким и читаемым. В нём нет выражение function, фигурных скобок и выражение return. Вместо это разрабочик может сосредочиться на деталях реализации.

### Упражнения:

* прочитать подробнее о [стрелочных функциях ES6](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

## Классы ES6

JavaScript ES6 ввёл классы. Класс обычно используется в объектно-ориентированных языках программирования. JavaScript был и есть очень гибкий в своих парадигмах программирования. Вы можете использовать функциональные програмирование и объектно-ориентированное программирование бок о бок для своих конкретных случаях использования.

Несмотря на то, что React охватывает функциональное программирование, например, с неизменяемыми структурами данных, классы используются для объявления компонентов. Они называются компонентами класса ES6. React смешивает хорошие части обеих парадигм программирования.

Давайте рассмотрим следующий класс Developer для изучения класса JavaScript ES6, не думая о компоненте.

{title="Code Playground",lang="javascript"}
~~~~~~~~
class Developer {
  constructor(firstname, lastname) {
    this.firstname = firstname;
    this.lastname = lastname;
  }

  getName() {
    return this.firstname + ' ' + this.lastname;
  }
}
~~~~~~~~

У класса есть конструктор, чтобы сделать его инстанцируемым. Конструктор может принимать агументы, чтобы их можно назначить экземпляру класса. Кроме того, класс может определять функции. Поскольку функция связана с классом, она называется методом. Часто она ссылается на метод класса.

Класс Developer - это только объявление класса. Вы можете создать несколько экземпляров класса путём вызова его. Он похож на компонент класса ES6, который имеет объявление, но вы должны использовать его в другом месте для создания.

Давайте посмотрим, как вы можете создать экземпляр класса и как использовать его методы.

{title="Code Playground",lang="javascript"}
~~~~~~~~
const robin = new Developer('Robin', 'Wieruch');
console.log(robin.getName());
// output: Robin Wieruch
~~~~~~~~

React использует классы JavaScript ES6 для компонентов классов ES6 . Вы уже использовали один компонент класса ES6 .

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';

...

class App extends Component {
  render() {
    ...
  }
}
~~~~~~~~

Класс App наследует `Component`. В основном вы объявляете компонент App, но он наследуется от другого компонента. Что значит наследуется? В объекто-ориентированном программировании у вас есть принцип наследования. Он используется для передачи функциональности одного класс к другому.

Класс App наследует функциональность из класса Component. Чтобы быть более конкретным, он наследует функциональность из класса Component. Класс Component используются для наследования базового класса ES6 в класс компонента ES6. Он имеет всю функциональность, которую компонент в React имеет. Метод render - одна из тех функциональностей, которые вы уже использовали. В дальнейшем вы узнаете о других методах класса компонента.

Класс `Component` инкапсулирует все детали реализации компонента React. Это позволяет разработчикам использовать классы как компоненты в React.

Методы, предоставляемые компонентом `Component`, являются открытым интерфейсом. Один из этих методов должен быть переопределён, другие не должны быть переопределены. Вы узнаете о последних методов, когда в этой книге будут рассматриваться методы жизненного цикла в последней главе. Метод `render()` должен быть переопределён, поскольку он определяет вывод компонента React `Component`. Он обязательно должен быть переопределён.

В данный момент вы узнали о основах классах JavaScript ES6 и то, как они используются в React для создания компонентов. Вы узнаете подробнее о методах Component, когда в книге будут описаны методы жизненного цикла React.

### Упражнения:

* узнать подробнее о [классах ES6](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes)

{pagebreak}

Вы научились создавать своё собственное React-приложение! Давайте вспомним последние темы:

* React
  * create-react-app для создания заготовки приложения React
  * JSX смешивает HTML и JavaScript для определения вывода React-компонентов в своих методах render
  * компоненты, экземпляры и элементы - разные вещи в React
  * `ReactDOM.render()` - это точка входа для React-прилложения, которая привязывает React к DOM
  * встроенная функциональность JavaScript functionalities может использоваться в JSX
    * map можно использовать для отрисовки списка элементов как HTML-элементы
* ES6
  * объявления переменных с помощью `const` и `let` могут использоваться в зависимости от конкретных случаев
    * использование const вместо let в React-приложений
  * стрелочные функции используются для краткого написания ваших функций
  * класы используются для определения компонентов в React путём их наследования

Имеет смысл сделать перерыв на данном этапе. Усвоить полученные знания и применить их на практике самостоятельно. Вы можете поэкспериментировать с исходным кодом, написанным в рамках этой главы. Его можно найти в [официальном репозитории](https://github.com/the-road-to-learn-react/hackernews-client/tree/5.1).
